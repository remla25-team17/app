import os
import requests
import psutil
from flask import Blueprint, jsonify, request
from requests.exceptions import RequestException, HTTPError
from flasgger import swag_from
from prometheus_client import Counter, Gauge, Histogram, generate_latest
from time import time

MODEL_SERVICE_URL = os.getenv('MODEL_SERVICE_URL')
APP_SERVICE_VERSION = os.getenv('APP_SERVICE_VERSION', 'unknown')

if not MODEL_SERVICE_URL:
    raise EnvironmentError("MODEL_SERVICE_URL environment variable is not set.")

num_requests_total = Counter("num_requests_total", "Total number of requests made to the sentiment API", ["endpoint", "status_code"])
request_latency_seconds = Histogram("request_latency_seconds", "Latency distribution of sentiment API requests, measured in seconds", ["endpoint", "status_code"])
cpu_usage_percent = Gauge("cpu_usage_percent", "Current CPU usage percentage")
ram_usage_percent = Gauge("ram_usage_percent", "Current RAM usage percentage")

sentiment_api = Blueprint("sentiment_api", __name__)

# The documentation in this file was generated by AI
@sentiment_api.route('/api/v1/sentiment', methods=['POST'])
@swag_from('specs/analyze_sentiment.yml')
def analyze_sentiment():
    """
    Analyze the sentiment of the provided input text by sending it to the model service.

    Expects JSON request body: {"text": "<input_text>"}

    Returns:
        Response: A JSON response with the sentiment result or an error message.
    """
    try:
        data = request.get_json()
        if not data or 'text' not in data:
            return jsonify({'error': 'Missing "text" field in JSON payload.'}), 400

        input_text: str = data['text']
        if not isinstance(input_text, str):
            return jsonify({'error': 'Input text must be a string.'}), 400
        if not input_text.strip():
            return jsonify({'error': 'Input text cannot be empty.'}), 400

    except ValueError:
        return jsonify({'error': 'Invalid JSON payload.'}), 400

    try:
        response = requests.post(
            url=f"{MODEL_SERVICE_URL}/api/v1/sentiment",
            json={'text': input_text}
        )
        response.raise_for_status()
        sentiment_prediction = response.json().get('sentiment')
    except HTTPError as e:
        return jsonify({'error': f"Error in model service: {str(e)}"}), 500
    except RequestException as e:
        return jsonify({'error': f"Failed to connect to model service: {str(e)}"}), 503

    return jsonify({'sentiment': sentiment_prediction}), 200


@sentiment_api.route('/api/v1/correct-prediction', methods=['POST'])
@swag_from('specs/correct_prediction.yml')
def correct_prediction():
    """
        Correct the predicted sentiment. As of now, this is not stored anywhere.
        """
    data = request.get_json()
    if not data or not all(field in data for field in ['text', 'original_prediction', 'corrected_prediction']):
        return jsonify({'error': 'Missing required fields in JSON payload.'}), 400

    return jsonify({'message': 'Your correction has been processed.'}), 200


@sentiment_api.route('/api/v1/version', methods=['GET'])
@swag_from('specs/get_version.yml')
def get_version():
    """
    Retrieve the version of the app and model service.

    Returns:
        Response: A JSON response with version information.
    """
    try:
        response = requests.get(f'{MODEL_SERVICE_URL}/api/v1/version')
        response.raise_for_status()
        model_service_version = response.json().get('model_service_version', 'unknown')
    except HTTPError as e:
        return jsonify({'error': f"Error in model service: {str(e)}"}), 500
    except RequestException as e:
        return jsonify({'error': f"Failed to connect to model service: {str(e)}"}), 503

    return jsonify(
        {
            'app_service_version': APP_SERVICE_VERSION,
            'model_service_version': model_service_version
         }
    ), 200

@sentiment_api.route('/api/v1/metrics', methods=['GET'])
@swag_from('specs/get_metrics.yml')
def get_metrics():
    """
    Collect and return Prometheus metrics.

    This endpoint collects the current system metrics, and then returns all metrics in a
    format compatible with Prometheus scraping.

    Returns:
        Response: A plaintext response with Prometheus metrics and HTTP 200 status.
    """
    collect_system_metrics()
    return generate_latest(), 200


def collect_system_metrics():
    """
    Update Prometheus metrics for CPU and RAM usage.

    Uses `psutil` to gather system usage statistics and sets them
    in the Prometheus Gauge metrics: `CPU_USAGE` and `RAM_USAGE`.
    """
    cpu_usage_percent.set(psutil.cpu_percent())
    ram_usage_percent.set(psutil.virtual_memory()[2])


@sentiment_api.before_request
def after_request():
    """
    This function is called before each request to track request latency.
    The start time is stored in `request.start_time`.
    """
    request.start_time = time()

@sentiment_api.after_request
def after_request(response):
    """
    Update Prometheus metrics and return the response.

    Increments the request counter and observes the request latency
    using Prometheus metrics.

    Args:
        response (Response): The Flask response object to return.

    Returns:
        Response: The original response object after updating metrics.
    """
    num_requests_total.labels(endpoint=request.path, status_code=response.status_code).inc()
    request_latency_seconds.labels(endpoint=request.path, status_code=response.status_code).observe(time() - request.start_time)

    return response